str(M)
hist(M)
for (i in 1:nrow(S)) S[i,] <- S[i,]/M
M2 <- apply(S, 1, median)
str(M2)
hist(M2)
for (i in 1:nrow(S)) S[i,] <- S[i,]/M2[i]
str(S)
range(S)
?cutree
ls()
data(SrE.IR)
evalClusters <-#
function(spectra, hclst,  k = NULL, h = NULL, crit = "all") {#
	ct <- cutree(hclst, k = k, h = h)#
	res <- intCriteria(spectra$data, ct, crit)#
	return(res)#
	}
tst <- evalClusters(SrE.IR, hca, h = 0.3)
hca <- hcaSpectra(SrE.IR)
str(hca)
hca
?list
data(metMUD1)#
chkSpectra(metMUD1, confirm = TRUE)
remove <- c(20:40) #
metMUD1$freq <- metMUD1$freq[-remove]
chkSpectra(metMUD1, confirm = TRUE)
data(metMUD1)#
sumSpectra(metMUD1)#
newSpec <- conColScheme(metMUD1,#
	new = c("pink", "violet"))#
sumSpectra(newSpec)
?cov2cor
library("ChemoSpec")
data(metMUD2)
?ChemoSpec
corSpectra <- function(spectra, plot = TRUE,#
	limX = NULL, limY = NULL,#
	nticks = 10, levels = NULL,#
	pmode = "contour",#
	C = NULL, V = NULL, ...) {#
	if (missing(spectra)) stop("No spectral data provided")#
	chkSpectra(spectra)#
	if (is.unsorted(spectra$freq)) {#
		spectra$freq <- rev(spectra$freq)#
		spectra$data <- spectra$data[,ncol(spectra$data):1]#
		}#
	if (is.null(C)) { #
		X <- spectra$data#
		if (ncol(X) > 10000) message("Calculating cor() may take a few minutes")#
		C <- cor(X) #
		}#
	if (is.null(V)) { #
		X <- spectra$data#
		if (ncol(X) > 10000) message("Calculating cov() may take a few minutes")#
		V <- cov(X) #
		}#
#
	if (ncol(C) > 8000) message("Graphical output will take some time with this many data points")#
	decor <- function(spectra, V, C, limX, limY, levels, pmode) {#
		if ((pmode == "contour") | (pmode == "image")) { #
			LX <- c(0, 1) #
			LY <- c(0, 1)#
			tickposX <- seq(LX[1], LX[2], length.out = nticks)#
			ticklabX <- (diff(range(spectra$freq)) * tickposX) + min(spectra$freq)#
			tickposY <- seq(LY[1], LY[2], length.out = nticks) #
			ticklabY <- (diff(range(spectra$freq)) * tickposY) + min(spectra$freq)#
#
			if (!is.null(limX)) { #
				l <- findInterval(limX[1], spectra$freq)#
				r <- findInterval(limX[2], spectra$freq)#
				limX<- c(l, r)#
				limX <- limX/ncol(C)#
				tickposX <- seq(limX[1], limX[2], length.out = nticks)#
				ticklabX <- (diff(range(spectra$freq)) * tickposX) + min(spectra$freq)#
				LX <- limX#
				}#
#
			if (!is.null(limY)) { #
				l <- findInterval(limY[1], spectra$freq)#
				r <- findInterval(limY[2], spectra$freq)#
				limY<- c(l, r)#
				limY <- limY/ncol(C)#
				tickposY <- seq(limY[1], limY[2], length.out = nticks)#
				ticklabY <- (diff(range(spectra$freq)) * tickposY) + min(spectra$freq)#
				LY <- limY#
				}#
			}#
		if ((pmode == "contourplot") | (pmode == "levelplot") | (pmode == "rgl")) { #
			LX <- c(1, ncol(C)) #
			LY <- c(1, ncol(C))#
			tickposX <- seq(LX[1], LX[2], length.out = nticks) #
			tickposX <- round(tickposX)#
			ticklabX <- spectra$freq[tickposX]		#
			tickposY <- seq(LY[1], LY[2], length.out = nticks) #
			tickposY <- round(tickposY)#
			ticklabY <- spectra$freq[tickposY]#
			if (!is.null(limX)) {#
				l <- findInterval(limX[1], spectra$freq)#
				r <- findInterval(limX[2], spectra$freq)#
				limX <- c(l, r)#
				tickposX <- seq(limX[1], limX[2], length.out = nticks) #
				tickposX <- round(tickposX)#
				ticklabX <- spectra$freq[tickposX]		#
				LX <- limX#
				}#
#
			if (!is.null(limY)) {#
				l <- findInterval(limY[1], spectra$freq)#
				r <- findInterval(limY[2], spectra$freq)#
				limY <- c(l, r)#
				tickposY <- seq(limY[1], limY[2], length.out = nticks) #
				tickposY <- round(tickposY)#
				ticklabY <- spectra$freq[tickposY]		#
				LY <- limY#
				}#
			}#
#
		if (pmode == "exCon") {#
			LX <- range(spectra$freq)#
			LY <- LX#
			ticklabX <- NA#
			ticklabY <- NA#
			tickposX <- NA#
			tickposY <- NA#
			if (!is.null(limX)) {#
				LX <- limX#
				}#
#
			if (!is.null(limY)) {#
				LY <- limY#
				}			#
			}#
		cscale <- c(rev(rainbow(4, start = 0.45, end = 0.66)), rev(rainbow(5, start = 0.0, end = 0.25)))#
		refscale <- seq(-1, 1, length.out = 9)#
		if ((pmode == "contour") | (pmode == "contourplot") | (pmode == "exCon")) {#
			if (is.null(levels)) {#
				levels <- chooseLvls(M = C, n = 5L, mode = "even")#
				msg <- paste("The levels chosen are:\n", paste(round(levels, 5), collapse = " "), sep = " ")#
				message(msg)#
				}	#
			myc <- cscale[findInterval(levels, refscale)]#
			}#
#
		if ((pmode == "image") | (pmode == "levelplot")) {#
#
			if (!is.null(levels)) {#
				myc <- cscale[findInterval(levels, refscale)]#
				nc <- length(myc)#
				if ((nc %% 2) == 1) myc <- myc[-ceiling(nc/2)]#
				if ((nc %% 2) == 0) myc <- myc[-floor(nc/2)]#
				}#
#
			if (is.null(levels)) { #
				levels <- chooseLvls(M = C, n = 5L, mode = "even") #
				msg <- paste("The levels chosen are:\n", paste(round(levels, 5), collapse = " "), sep = " ")#
				message(msg)#
				myc <- cscale[c(1, 3, 7, 9)] #
				}#
			}#
		if (pmode == "rgl") {#
			myc <- cscale[findInterval(C, refscale)] #
			}#
		lab <- spectra$unit[1]#
		if (lab == "ppm") {#
			ticklabX <- as.character(round(ticklabX, 2))#
			ticklabY <- as.character(round(ticklabY, 2))#
			}#
		if (lab == "wavenumber") {#
			ticklabX <- as.character(round(ticklabX, 0))#
			ticklabY <- as.character(round(ticklabY, 0))#
			}#
		L <- list(myc = myc, lab = lab, limX = LX, limY = LY,#
			tickposX = tickposX, tickposY = tickposY,#
			ticklabX = ticklabX, ticklabY = ticklabY,#
			levels = levels,#
			refscale = refscale, cscale = cscale)#
		return(L)#
		} #
	if (plot) {#
		d <- decor(spectra, V, C, limX, limY, levels, pmode)#
		if (pmode == "levelplot") {#
			p <- levelplot(C, xlab = d[[2]], ylab = d[[2]],#
				col.regions = d[[1]],#
				scales = list(#
					x = list(at = d[[5]], labels = d[[7]]),#
					y = list(at = d[[6]], labels = d[[8]])),#
				xlim = d[[3]], ylim = d[[4]],#
				at = d[[9]],#
				colorkey = list( #
					at = d[[10]],#
					col = d[[11]],#
					labels = list(#
					at = seq(-1.0, 1.0, by = 0.2), #
                         labels = as.character(seq(-1.0, 1.0, by = 0.2)))),#
				...)#
			print(p)#
			}#
		if (pmode == "contourplot") {#
			p <- contourplot(C, xlab = d[[2]], ylab = d[[2]],#
				col.regions = d[[1]],#
				region = TRUE,#
				scales = list(#
					x = list(at = d[[5]], labels = d[[7]]),#
					y = list(at = d[[6]], labels = d[[8]])),#
				xlim = d[[3]], ylim = d[[4]],#
				labels = FALSE,#
				at = d[[9]], #
				colorkey = list( #
					at = d[[10]],#
					col = d[[11]],#
					labels = list(#
						at = seq(-1.0, 1.0, by = 0.2), #
                        labels = as.character(seq(-1.0, 1.0, by = 0.2)))),#
				...)#
			print(p)#
			}#
		if (pmode == "image") {#
			image(C, xlab = d[[2]], ylab = d[[2]],#
				col = d[[1]], xlim = d[[3]], ylim = d[[4]],#
				breaks = d[[9]],#
				xaxt = "n", yaxt = "n", useRaster = TRUE, ...)			#
			axis(1, at = d[[5]], labels = d[[7]])			#
			axis(2, at = d[[6]], labels = d[[8]])			#
			}#
#
		if (pmode == "contour") {#
			contour(C, xlab = d[[2]], ylab = d[[2]],#
				xlim = d[[3]], ylim = d[[4]],#
				col = d[[1]],#
				levels = d[[9]],				#
				drawlabels = FALSE,#
				axes = FALSE, frame.plot = TRUE,#
				xaxs = "i", yaxs = "i", ...)#
			axis(1, at = d[[5]], labels = d[[7]])			#
			axis(2, at = d[[6]], labels = d[[8]])			#
			}#
		if (pmode == "exCon") {#
#
			x1 <- findInterval(d[[3]][1], spectra$freq)#
			x2 <- findInterval(d[[3]][2], spectra$freq)#
			y1 <- findInterval(d[[4]][1], spectra$freq)#
			y2 <- findInterval(d[[4]][2], spectra$freq)#
			Z <- C[x1:x2, y1:y2]#
			exCon(M = Z, levels = d[[9]],#
				x = seq(d[[3]][1], d[[3]][2], length.out = ncol(Z)),#
				y = seq(d[[4]][1], d[[4]][2], length.out = nrow(Z)),#
				, ...)		#
			}#
#
		if (pmode == "rgl") {#
			x1 <- d[[3]][1]#
			x2 <- d[[3]][2]#
			y1 <- d[[4]][1]#
			y2 <- d[[4]][2]#
			Z <- C[x1:x2, y1:y2]#
			np <- nrow(Z)#
			while(abs(max(Z)/np) < 0.40) {#
				Z <- Z * 1.5	#
				}#
#
			open3d(windowRect = c(0, 0, 800, 800))#
			surface3d(x = 1:np, y = 1:np, z = Z, color = d[[1]])#
			}#
#
		}#
	L <- list(cov = V, cor = C)#
	invisible(L)#
	}
lvs <- c(-0.95, -0.9, 0.9, 0.95)#
lim <- c(0.6, 4.3)#
#
tst <- corSpectra(metMUD2, levels = lvs, pmode = "contour", limX = lim, limY = lim)
?as.matrix
?dist
x <- matrix(rnorm(100), nrow = 5)#
dist(x)
str(as.matrix(x))
as.matrix(x)
?as.distance
?as.dist
mypairs <- function(x) {#
	np <- length(x)#
	M <- matrix(NA_real_, np, np)#
	for (i in 1:np) {#
		for (j in 1:np) {#
			M[i,j] <- x[j]-x[i]#
			}#
		}#
	M <- abs(M)#
	}
mypairs <- function(x) {#
	np <- length(x)#
	M <- matrix(NA_real_, np, np)#
	for (i in 1:np) {#
		for (j in 1:np) {#
			if (j > i) M[i,j] <- x[j]-x[i]#
			}#
		}#
	M <- abs(M)#
	}
tst <- mypairs(rnorm(3)); tst
mypairs <- function(x) {#
	np <- length(x)#
	M <- matrix(NA_real_, np, np)#
	for (i in 1:np) {#
		for (j in 1:np) { #
			if (j > i) M[i,j] <- x[j]-x[i]#
			}#
		}#
	M <- abs(M)#
	v <- vector("numeric", np^2)#
	for (i in 1:np) {#
		v[(np*(i-1)+1):(np*i)] <- M[,i]#
		}#
	idx1 <- rep(1:np, np)#
	idx2 <- rep(1:np, each = np)#
	v#
	}
mypairs <- function(x) {#
	np <- length(x)#
	M <- matrix(NA_real_, np, np)#
	for (i in 1:np) {#
		for (j in 1:np) { #
			if (j > i) M[i,j] <- x[j]-x[i]#
			}#
		}#
	M <- abs(M)#
	v <- vector("numeric", np^2)#
	for (i in 1:np) {#
		v[(np*(i-1)+1):(np*i)] <- M[,i]#
		}#
	idx1 <- rep(1:np, np) #
	idx2 <- rep(1:np, each = np) #
	print(idx1)#
	print(idx2)#
	v#
	}
tst <- mypairs(rnorm(3)); tst#
#
mypairs <- function(x) {#
	require("plyr")#
	np <- length(x)#
	M <- matrix(NA_real_, np, np)#
	for (i in 1:np) {#
		for (j in 1:np) { #
			if (j > i) M[i,j] <- x[j]-x[i]#
			}#
		}#
	M <- abs(M)#
	d <- vector("numeric", np^2)#
	for (i in 1:np) {#
		d[(np*(i-1)+1):(np*i)] <- M[,i]#
		}#
	idx1 <- rep(1:np, np) #
	idx2 <- rep(1:np, each = np) #
	nope <- which(is.na(d))#
	d <- d[-nope]#
	idx1 <- idx1[-nope]#
	idx2 <- idx2[-nope]#
	df <- data.frame(dist = d, ptA = idx1, ptB = idx2)#
	df <- arrange(df, desc(d))#
	df#
	}
tst <- mypairs(rnorm(10)); tst
mypairs <- function(x) {#
	require("plyr")#
	np <- length(x)#
	M <- matrix(NA_real_, np, np)#
	for (i in 1:np) {#
		for (j in 1:np) { #
			if (j > i) M[i,j] <- x[j]-x[i]#
			}#
		}#
	M <- abs(M)#
	d <- vector("numeric", np^2)#
	for (i in 1:np) {#
		d[(np*(i-1)+1):(np*i)] <- M[,i]#
		}#
	idx1 <- rep(1:np, np) #
	idx2 <- rep(1:np, each = np) #
	nope <- which(is.na(d))#
	d <- d[-nope]#
	idx1 <- idx1[-nope]#
	idx2 <- idx2[-nope]#
	df <- data.frame(dist = d, ptA = idx1, ptB = idx2)#
	df <- arrange(df, d)#
	df#
	}
system.time(tst <- mypairs(rnorm(10)))
system.time(tst <- mypairs(rnorm(1000)))
system.time(tst <- mypairs(rnorm(2000)))
system.time(tst <- mypairs(rnorm(5000)))
system.time(tst <- mypairs(rnorm(10000)))
head(tst)
tail(tst)
